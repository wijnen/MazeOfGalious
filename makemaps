#!/usr/bin/python3
# vim: set foldmethod=marker fileencoding=utf-8 :

# Imports {{{
import sys
import struct
import numpy
from PIL import Image
from PIL import ImageDraw
import read_patterns
import read_sprites
# }}}

# Palette {{{
palette = ((0, 0, 0,
		0, 0, 0,
		62, 184, 73,
		116, 208, 125,
		89, 85, 224,
		128, 118, 241,
		185, 94, 81,
		101, 219, 239,
		219, 101, 89,
		255, 137, 125,
		204, 195, 94,
		222, 208, 135,
		58, 162, 65,
		183, 102, 181,
		204, 204, 204,
		255, 255, 255,
	))
# }}}

def get_room_charset(room): # {{{
	'Every room has a charset (16 options). This function reads the charset id for a given room.'
	d = rom[0x140d7 + (room + 1) // 2]
	if (room + 1) & 1:
		return d & 0xf
	else:
		return d >> 4
# }}}

# Prepare global rom. {{{
rom = open('MazeOfGalious.rom', 'rb').read()
# Get pointers for rom to each world. First world is the castle.
world = struct.unpack('<' + 'H' * 11, rom[0xeac0:0xead6])
# Convert pointers in CPU view to pointers in flat ROM image.
world = [x - 0x6000 + 0xe000 for x in world]
# Compute number of rooms from address of next room. This does not work for the last world, so hardcode that value.
rooms = [(world[x + 1] - world[x]) // 40 for x in range(len(world) - 1)] + [6]
# Read charset ids for all castle rooms.
charset_id = [get_room_charset(i) for i in range(rooms[0])]
# Rooms are built from tiles of 4x4 characters. There are a total of 0xac tiles defined.
tiles = numpy.array([[[rom[0xe000 + t * 0x10 + y * 4 + x] for x in range(4)] for y in range(4)] for t in range(0xac)], dtype = numpy.uint8)
# }}}

# Enemy names taken from openmsx mog overlay. {{{
enemy_names = (None, "Gorilla", "Twinkle", "HorBlob", "Gate", "Fire Snake", "06", "Ring Worm",
		"08", "09", "Knight", "Water Strider", "Sparky", "Fish", "Bat", "Pacman",
		"Insect", "Hedgehog", "Rockman", "Cloud Demon", "Mudman", "Ill", "Bird Dragon", "Egg Bird",
		"Worm", "Butterfly", "Snake's Fire", "Fireball", "1C", "1D", "1E", "Goblin",
		"Shadow Blob", "Crawler", "Pea Shooter", "Trapwall", "Swine", "Bones", "Living Helmet", "Owl",
		"Ectoplasm", "Drifting Cloud", "Poltergeist", "Wizard", "Shoe 1", "Frost Demon", "Bamboo Shoot", "Frog Plant",
		"Seahorse Demon", "Gas", "Armor>", "Armor's Dart", "Bally", "35", "DingDong", "Great Butterfly",
		"VerBlob", "39", "Moai>", "Moai Head Projectile", "Trickster Ghost", "Star", "Flocking Bird", "3F",
		"Cyclop's Ghost", "41", "Maner", "Gero", "44", "45", "46", "47",
		"48", "Huge Bat", "4A", "4B", "Fuzzball", "4D", "Fairy Dust", "4F",
		"<Moai", "<Armor", "Middle Bat", "Mini Bat", "Bone", "Small Bone", "Small Fireball", "57",
		"Crab's Breath", "Seed", "5A", "5B", "Spiral Ball ", "5D", "5E", "5F",
		"Maner's Arm", "61", "Gero's Tongue", "63", "Shoe 2", "Breath", "66", "Protectors",
		"68", "Thunder Cloud", "6A", "6B", "6C", "6D", "6E", "6F",
		"70", "71", "72", "73", "74", "75", "76", "77",
		"78", "79", "7A", "7B", "7C", "7D", "7E", "7F")
# }}}

# Find sprite codes that are loaded for a room. Can be used to check that sprite patterns are available and to map sprite names to their enemy codes. {{{
room_sprites = []
for w, num_rooms in enumerate(rooms):
	room_sprites.append([None])
	ptr = 0x17737 + 2 * (w + 1)
	ptr = struct.unpack('<H', rom[ptr:ptr + 2])[0] - 0x8000 + 0x16000
	# ptr is now pointing at a list of enemy codes that are loaded for this room.
	room = 0
	for room in range(num_rooms):
		room_sprites[-1].append([])
		while rom[ptr] != 0:
			room_sprites[-1][-1].append(rom[ptr])
			ptr += 1
		ptr += 1
# }}}

def makeimage(world_num, room_num, roomdata, charset_id, extra): # {{{
	'Convert rom into image'
	im = Image.new('RGB', (32 * 8, 20 * 8))
	imt = ImageDraw.Draw(im)
	# Draw screen background (and regular walls) {{{
	for y in range(20):
		for x in range(32):
			c = read_patterns.get_char(read_patterns.sets[charset_id], roomdata[y, x])
			if roomdata[y, x] != 0x6c: # Hide walk-through walls.
				if c is not None:
					im.paste(read_patterns.get_char(read_patterns.sets[charset_id], roomdata[y, x]), (8 * x, 8 * y))
			else:
				im.paste(read_patterns.get_char(read_patterns.sets[charset_id], roomdata[y, x]), (8 * x, 8 * y), Image.new('L', (8, 8), 0xc0))
	# }}}
	# Draw boulders first, so that what's behind can be shown on top. {{{
	if extra['boulder'] is not None:
		for x, y in extra['boulder']:
			im.paste(read_patterns.boulder_img, (x, y, x + 16, y + 16))
	# }}}
	if extra['traps'] is not None: # {{{
		for x, y, traptype in extra['traps']:
			detail = (traptype >> 4) & 0xf
			traptype &= 0xf
			if traptype == 1:	# key door in castle
				trap_img = read_patterns.composite([0], [[0xc5]] * 3)
				im.paste(trap_img, (x, y))
			elif traptype == 2:	# key door in world
				trap_img = read_patterns.composite([0], [[0xc6], [0xc7], [0xc8]])
				im.paste(trap_img, (x, y))
			elif traptype == 3:	# one way push door
				if detail == 0:		# <-
					chars = [[0xda, 0x83, 0x95]] * 3
				elif detail == 1:	# ->
					chars = [[0x8f, 0x83, 0xd3]] * 3
				else:
					raise AssertionError('unrecognized detail for door')
				trap_img = read_patterns.composite([0], chars)
				im.paste(trap_img, (x - 0x8, y))
			elif traptype == 4:	# push door (blue)
				trap_img = read_patterns.composite([0], [[0xd0], [0xd1], [0xd2]])
				im.paste(trap_img, (x, y))
			elif traptype == 5:	# trap wall.
				trap_img = read_patterns.composite([0], [[0xf0]] * 3)
				t = Image.new('L', trap_img.size, 128)
				im.paste(trap_img, (x, y), t)
			elif traptype == 6:
				# Appearing stones on the water. Coordinate is not used.
				# Y is hardcoded to 0x78. X are 4 values taken from *a630 @789.
				stone = read_patterns.composite([0], [[0xc2, 0xc3]])
				for i in range(4):
					x = rom[0xa630 - 0x6000 + 0x2000 * 7 + i]
					im.paste(stone, (x, 0x78 - 0x20), Image.new('L', stone.size, 128))
			elif traptype == 7:	# destructible wall
				trap_img = read_patterns.composite([0 if world_num == 0 else 1], [[0xf0] * 4] * 3)
				im.paste(Image.new('L', trap_img.size, 0), (x, y))
				t = Image.new('L', trap_img.size, 128)
				im.paste(trap_img, (x, y), t)
			else:
				imt.text((x, y), '%x' % traptype)
				print('trap? item world %x room %02x x %02x y %02x type %02x' % (world_num, room_num + 1, x, y, traptype))
	# }}}
	if extra['item'] is not None: # {{{
		item_item, item_x, item_y = extra['item']
		itemimg = read_patterns.items[item_item]
		# Special handling for items in destructible walls.
		if extra['traps'] is not None and any((item_x & 0xe0) == x and (item_y & 0xe0) == y for x, y, traptype in extra['traps'] if (traptype & 0xf) == 7):
			t = Image.eval(itemimg.convert('L'), lambda p: 0xc0 if p == 0 else 255)
			im.paste(itemimg, (item_x, item_y, item_x + itemimg.size[0], item_y + itemimg.size[1]), t)
		elif extra['boulder'] is not None and (item_x, item_y) in extra['boulder']:
			t = Image.eval(itemimg.convert('L'), lambda p: 128 if p == 0 else 255)
			im.paste(itemimg, (item_x, item_y, item_x + itemimg.size[0], item_y + itemimg.size[1]), t)
		else:
			im.paste(itemimg, (item_x, item_y, item_x + itemimg.size[0], item_y + itemimg.size[1]))
	# }}}
	if extra['shrine'] is not None: # {{{
		shrine_id, shrine_x, shrine_y = extra['shrine']
		if extra['boulder'] is not None and (shrine_x, shrine_y) in extra['boulder']:
			t = Image.eval(read_patterns.shrine_img.convert('L'), lambda p: 128 if p == 0 else 255)
			im.paste(read_patterns.shrine_img, (shrine_x, shrine_y, shrine_x + 16, shrine_y + 16), t)
		else:
			im.paste(read_patterns.shrine_img, (shrine_x, shrine_y, shrine_x + 16, shrine_y + 16))
		imt.text((shrine_x + 5, shrine_y + 5), '%x' % shrine_id, fill = (0, 0, 255))
	# }}}
	if extra['worlddoor'] is not None: # {{{
		num, x, y = extra['worlddoor']
		im.paste(read_patterns.worlddoor_img, (x, y, x + 32, y + 24))
		imt.text((x + 13, y + 13), '%x' % num, fill = (255, 255, 255))
	# }}}
	if extra['ladder'] is not None: # {{{
		x, y, h = extra['ladder']
		limg = read_patterns.composite([0], [[0x9a, 0x9b]])
		t = Image.new('L', limg.size, 128)
		for i in range(h):
			im.paste(limg, (x, (y + i * 8) - 0x20), t)
	# }}}
	if extra['elevator'] is not None: # {{{
		e = extra['elevator']
		sprite = read_sprites.elevator
		if e['limit'] is not None:
			x, y = e['limit']
			im.paste(sprite, (x, y), sprite)
			im.paste(sprite, (x + 0x10, y), sprite)
		t = Image.new('L', sprite.size, 0x80)
		for x, y in e['path']:
			im.paste(sprite, (x, y), t)
			im.paste(sprite, (x + 0x10, y), t)
	# }}}
	# Draw enemies. {{{
	unused_enemies = set(room_sprites[world_num][room_num + 1])
	if extra['enemy'] is not None:
		for e in extra['enemy']:
			fixes = {0x64: 0x2c, 0x69: 0x06}
			code = fixes.get(e[0], e[0])
			num = extra['enemy'][e]
			pos = e[1], e[2] - 32
			boss_map = {0x3a: 0x00, 0x50: 0x02, 0x32: 0x04, 0x51: 0x05, 0x5c: None, 0x04: None} # Moais and armors, and baby in boulder
			if code in boss_map:
				block = boss_map[code]
				if block is None:
					if code == 4:
						# Hanging snake ("Gate"). Draw as image.
						target = read_patterns.composite([4], [[0xb5], [0x99]])
					else:
						# Baby option. Show baby in boulder.
						baby = read_sprites.bosses[0x17]
						boulder = read_sprites.bosses[0x39]
						target = baby.copy()
						target.paste(boulder, (0, 0), Image.new('L', boulder.size, 128))
				else:
					target = read_sprites.bosses[block]
				im.paste(target, pos)
			else:
				if code not in room_sprites[world_num][room_num + 1]:
					print('warning: wrong sprite in room %d %02x? %02x(%s) not in %s' % (world_num, room_num + 1, code, enemy_names[code], ','.join('%02x(%s)' % (x, enemy_names[x]) for x in room_sprites[world_num][room_num + 1])))
				elif code in unused_enemies:
					unused_enemies.remove(code)
				if code == 0x31 and not (pos[1] & 8):
					# Gas at odd row show use different sprite.
					sprite = read_sprites.sprite_imgs[code][7]
				else:
					sprite = read_sprites.sprites[code]
				im.paste(sprite, pos, sprite)
				#imt.text(pos, enemy_names[code], fill = (255, 255, 255))
			if num > 1:
				imt.text((pos[0], pos[1] + 12), 'x%d' % num, fill = (255, 255, 255))
	# TODO: show unused enemies on screen as well.
	# }}}
	return im
# }}}

# Make images of all rooms. {{{
out = []

# Keep some data about shrines to add their images to the map later.
shrineroom = {}

for idx, w in enumerate(world):
	# Create all lists so they exist even without contents.
	items = {}	# key is room, value is id, x, y
	shrines = {}
	worlddoor = {}
	enemies = {}
	boulders = {}
	ladders = {}
	traps = {}
	elevator = {}
	if idx == 0: # Only in castle.
		# Find shrines {{{
		target = 0x5dda
		while rom[target] != 0:
			room, shrine_id, shrine_y, shrine_x = rom[target:target + 4]
			shrineroom[shrine_id] = room
			# Room-1, because this rom starts counting at 1. y-32, because the coordinate includes the screen header.
			shrines[room - 1] = [shrine_id, shrine_x, shrine_y - 32]
			target += 4
		# }}}
		# Find worlddoors {{{
		for num, target in enumerate(range(0x9990, 0x9999)):
			room = rom[target - 0x8000 + 2 * 0x2000]
			addr = 0x9997 + (num + 1) * 2 - 0x8000 + 2 * 0x2000
			y, x = rom[addr:addr + 2]
			#print('door %x %x %x %x' % (num + 1, room, x, y))
			worlddoor[room - 1] = (num + 1, x, y - 32)
		# }}}
		# Find boulders {{{
		target = 0xb8a2 - 0xa000 + 9 * 0x2000
		room = 0
		while room < rooms[idx]:
			if rom[target] == 0:
				target += 1
				room += 1
				continue
			if room not in boulders:
				boulders[room] = []
			x = (rom[target] << 3) & 0xf8
			y = ((rom[target] & 0xe0) | 8) - 32
			boulders[room].append((x, y))
			target += 1
		# }}}
		# Find vertical elevators. {{{
		for e in range(6):
			ptr = 0xbb24 - 0xa000 + 9 * 0x2000 + 8 * (5 - e)
			y, x, dx, dy, top_room, top_y, bottom_room, bottom_y = rom[ptr:ptr + 8]
			roomslistptr = 0xba80 + 2 * e - 0xa000 + 9 * 0x2000
			roomsptr = struct.unpack('<H', rom[roomslistptr:roomslistptr + 2])[0] - 0xa000 + 9 * 0x2000
			assert top_room == rom[roomsptr]
			erooms = []
			while rom[roomsptr] != bottom_room:
				erooms.append(rom[roomsptr])
				roomsptr += 1
			# Elevator struct should be filled per room.
			elevator[top_room - 1] = {'limit': (x, top_y - 0x20), 'path': [(x, 0x98)]}
			elevator[bottom_room - 1] = {'limit': (x, bottom_y - 0x20), 'path': [(x, -0x8)]}
			for r in erooms[1:]:
				elevator[r - 1] = {'limit': None, 'path': [(x, -0x8), (x, 0x50), (x, 0x98)]}
		# }}}
	# Also in worlds.
	# Find disappearing ladders {{{
	for i in range(0xd):
		addr = 0x126eb + i * 2
		ldata = 0x12700 + (i + 1) * 5
		lw, lr = rom[addr:addr + 2]
		if lw != idx + 1:
			continue
		y, x, h, _, _ = rom[ldata:ldata + 5]
		ladders[lr - 1] = [x, y, h]
	# }}}
	# Find traps {{{
	# traps is a dict. traps[room] = [[x, y, traptype], ...]
	world_ptr = 0xa7bc + (idx + 1) * 2 - 0x6000 + 7 * 0x2000
	ptr = struct.unpack('<H', rom[world_ptr:world_ptr + 2])[0] - 0x6000 + 7 * 0x2000
	#print('loop for world %x' % idx)
	for traproom in range(rooms[idx]):
		while rom[ptr] != 0:
			#print('world %x room %02x ptr %05x' % (idx, traproom, ptr))
			traptype, coord = rom[ptr:ptr + 2]
			y = (coord & 0xe0) - 0x20
			x = (coord << 3) & 0xf8
			ptr += 2
			if traproom not in traps:
				traps[traproom] = []
			traps[traproom].append((x, y, traptype))
		ptr += 1
	# }}}
	# Find enemies {{{
	target = 0xb5cb + (idx + 1) * 2 - 0xa000 + 6 * 0x2000
	e = struct.unpack('<H', rom[target:target + 2])[0] - 0xa000 + 6 * 0x2000
	room = 0
	while room < rooms[idx]:
		if rom[e] == 0:
			room += 1
			e += 1
			continue
		if room not in enemies:
			enemies[room] = {}
		etype = rom[e] & 0x7f
		ey = rom[e + 1] & 0xf8
		ex = ((rom[e + 1] << 5) | ((rom[e] & 0x80) >> 3)) & 0xf0
		record = (etype, ex, ey)
		if record not in enemies[room]:
			enemies[room][record] = 0
		enemies[room][record] += 1
		#print('enemy %s at %02x %02x in room %02x world %d' % (enemy_names[etype], ex, ey, room + 1, idx))
		e += 2
	# }}}
	# Find items {{{
	itemworldaddr = 0xb6fc + 2 * (idx + 1) - 0xa000 + 9 * 0x2000
	itemptr = struct.unpack('<H', rom[itemworldaddr:itemworldaddr + 2])[0] - 0xa000 + 9 * 0x2000
	while rom[itemptr] != 0:
		# Data is: room(8-bit) x4,x3,item(6-bit) y7,y6,y5,y4,y3,x7,x6,x5
		room, xitem, yx = rom[itemptr:itemptr + 3]
		item = xitem & 0x3f
		y = yx & 0xf8
		x = ((yx & 0x7) << 5) | ((xitem & 0xc0) >> 3)
		# Weapons are half height.
		if item < 7:
			y += 8
		items[room - 1] = (item, x, y - 0x20)
		#print('item found @%x: world %x room %x item %x x %x y %x' % (itemptr, idx, room, item, x, y))
		itemptr += 3
	# }}}
	# Create all rooms in a world. (14x20 characters per room)
	fullmap = numpy.zeros((rooms[idx], 0x14, 0x20), dtype = numpy.uint8)
	# Read tiles in a room (8x5, so 40 bytes total).
	roomdata = numpy.array([[x for x in rom[w + 40 * room:w + 40 * (room + 1)]] for room in range(rooms[idx])], dtype = numpy.uint8).reshape((rooms[idx], 5, 8))
	# Unpack characters from tiles. {{{
	for y in range(5):
		for x in range(8):
			fullmap[:, y * 4:(y + 1) * 4, x * 4:(x + 1) * 4] = [tiles[roomdata[r, y, x]] for r in range(rooms[idx])]
	# }}}
	# Convert character map to image.
	worldmap = []
	for r in range(rooms[idx]):
		extra = {
			'item': items.get(r),
			'shrine': shrines.get(r),
			'worlddoor': worlddoor.get(r),
			'enemy': enemies.get(r),
			'boulder': boulders.get(r),
			'ladder': ladders.get(r),
			'traps': traps.get(r),
			'elevator': elevator.get(r),
		}
		#print('world %d room %x' % (idx, r))
		worldmap.append(makeimage(idx, r, fullmap[r], charset_id[r] if idx == 0 else 7, extra))
	out.append(worldmap)
# }}}

# Link stuff together. {{{
worldmap = []
textmap = []
invalid = Image.new('RGB', (256, 160), (0xc0, 0x20, 0xc0))
# Prepare rom structure for storing all room exits.
exits = [numpy.zeros((4, rooms[w]), dtype = numpy.uint8) for w in range(11)]
# Compute bounding box.
l = [[0, 0] for w in range(11)]
h = [[0, 0] for w in range(11)]
for w in range(11):
	waddr = 0x129f1 + 2 * w
	# Convert from CPU view to flat ROM address.
	a = struct.unpack('<H', rom[waddr:waddr + 2])[0] - 0xa000 + 0x12000
	# Read all exits.
	for r in range(rooms[w]):
		raddr = a + 4 * (r + 1)
		exits[w][:, r] = struct.unpack('<BBBB', rom[raddr:raddr + 4])
	# check if values are sane.
	for r in range(rooms[w]):
		for e in range(4):
			target = exits[w][e, r]
			# rooms[w] + 1 is meeting a god; 0xff - w is world exit
			if target == 0xff or target == 0xff - w or target == rooms[w] + 1:
				#print 'world %d, found room %x' % (w, target)
				continue
			if not 0 < target <= rooms[w]:
				print('invalid exit %d=%x for room %x world %d' % (e, target, r, w))
				continue
			# World 4, room 4 has an upper exit to itself; ignore it.
			if (r + 1, w + 1, e) != (4, 4, 0) and exits[w][e ^ 1, target - 1] != r + 1:
				print("exit %d=%x for room %x world %d doesn't return (%x)" % (e, exits[w][e, r], r + 1, w + 1, exits[w][e ^ 1, exits[w][e, r] - 1]))
				continue
			#print 'exit %d room %x world %d is %x; exit %d room %x world %d is %x' % (e, r, w, target, e ^ 1, target, w, exits[w][e ^ 1, target - 1])
	# compute screen positions. Do a flood fill and compute bounding boxes along the way.
	screenpos = {1: numpy.array((0, 0))}
	queue = [list(screenpos.keys())[0]]
	done = set()
	todo = set(range(1, rooms[w] + 1))
	delta = numpy.array(((0, -1), (0, 1), (-1, 0), (1, 0)))
	if w == 0:
		# Screen 94 is not linked, but belongs at (1,-1). Link it there.
		screenpos[94] = numpy.array((1, -1))
		todo.remove(94)
		done.add(94)
		h[w][0] = 1
		l[w][1] = -1
	elif w == 10:
		# Screen 6 is not linked, but belongs at (5,0). Link it there.
		screenpos[6] = numpy.array((5, 0))
		todo.remove(6)
		done.add(6)
		h[w][0] = 5
	while queue != []:
		current = queue.pop(0)
		todo.remove(current)
		for e in range(4):
			target = exits[w][e, current - 1]
			if target == 0xff:
				continue
			# World 4, room 4 has an upper exit to itself; ignore it.
			if w == 3 and current == 4 and e == 0:
				assert current == target
				continue
			if target in screenpos:
				if not all(screenpos[target] == screenpos[current] + delta[e]):
					print('screen %d exists in different position (%s != %s)' % (target, str(screenpos[target]), str(screenpos[current] + delta[e])))
				continue
			# Add screen in any case.
			x, y = screenpos[current] + delta[e]
			double = [s for s in screenpos if screenpos[s][0] == x and screenpos[s][1] == y]
			if double != []:
				print('two screens in one position: %x %x' % (double[0], target))
			screenpos[target] = x, y
			# Update bounding box.
			if x < l[w][0]:
				l[w][0] = x
			if x > h[w][0]:
				h[w][0] = x
			if y < l[w][1]:
				l[w][1] = y
			if y > h[w][1]:
				h[w][1] = y
			# Only add real screens to queue.
			if 0 < target <= rooms[w]:
				queue.append(target)
		done.add(current)
	#print('done: %d/%d, todo: %s, w,h=%d,%d' % (len(done), rooms[w], str(todo), h[w][0] - l[w][0], h[w][1] - l[w][1]))
#print '\n'.join(['world %d; address: %05x rooms: %d' % (n, x, rooms[n]) for n, x in enumerate(world)])

	# Create the world image.
	size = h[w][0] - l[w][0] + 1, h[w][1] - l[w][1] + 1
	textmap.append([['  ' for x in range(size[0])] for y in range(size[1])])
	worldmap.append(Image.new('RGBA', (size[0] * 257 - 1, size[1] * 161 - 1), (0, 0, 0, 0)))
	worldmapt = ImageDraw.Draw(worldmap[w])
	for sp in screenpos:
		tx = screenpos[sp][0] - l[w][0]
		ty = screenpos[sp][1] - l[w][1]
		# Add 1 pixel to separate screens in the image.
		x = tx * 257
		y = ty * 161
		if w > 0:
			god_room = rom[0x8f0a - 0x6000 + 0x2000 * 1 + (w - 1)]
			god_id = rom[0x8f14 - 0x6000 + 0x2000 * 1 + (w - 1)]
			if sp == god_room:
				# This is the god room of this world.
				worldmap[w].paste(read_patterns.gods[god_id], (x, y))
				textmap[w][ty][tx] = '[]'
				continue
		if 0 < sp <= rooms[w]: 
			debug_charset = False	# w == 0	# Use this to debug charsets castle.
			worldmap[w].paste(out[w][sp - 1], (x, y, x + 256, y + 160))
			textmap[w][ty][tx] = '%02x' % sp
			worldmapt.rectangle((x, y, x + 15 + (15 if debug_charset else 0), y + 10), fill = (0, 0, 0))
			if debug_charset:
				worldmapt.text((x + 2, y), "%02x/%x" % (sp, charset_id[sp - 1]), fill = (255, 255, 255))
			else:
				worldmapt.text((x + 2, y), "%02x" % sp, fill = (255, 255, 255))
		elif sp >= 0xf0:
			worldmap[w].paste(read_patterns.world_screen(w), (x, y))
		else:
			print('invalid room %x %02x' % (w, sp))
			worldmap[w].paste(invalid, (x, y))
			textmap[w][ty][tx] = '++'
	if w == 0:
		# Place gods rooms in empty places next to their entrance.
		up, down, left, right = (0, -1), (0, 1), (-1, 0), (1, 0)
		godpos = [up, (0, -2), left, right, up, up, down, down, up, up, up]
		for s, shrinepos in enumerate(godpos):
			shrine_id = s + 1
			tx = screenpos[shrineroom[shrine_id]][0] - l[w][0] + shrinepos[0]
			ty = screenpos[shrineroom[shrine_id]][1] - l[w][1] + shrinepos[1]
			worldmap[w].paste(read_patterns.gods[shrine_id], (tx * 0x101, ty * 0xa1))
# }}}

# Create images of all room tiles. {{{
offset = 0x10
tile_img = []
all_tiles_img = Image.new('RGB', (offset + 0x21 * len(read_patterns.sets) - 1, len(tiles) * 0x21 - 1), (0, 0, 0xb0))
all_tiles_draw = ImageDraw.Draw(all_tiles_img)
for tile_num, tile_data in enumerate(tiles):
	tile_img.append(Image.new('RGB', (0x21 * len(read_patterns.sets) - 1, 0x20), (0, 0, 0xb0)))
	for charset_num, charset in enumerate(read_patterns.sets):
		good = True
		for y in range(4):
			for x in range(4):
				#:print(tile_data, tile_data[y, x], charset)
				char = read_patterns.get_char(charset, tile_data[y, x])
				if char is not None:
					tile_img[-1].paste(char, (0x21 * charset_num + x * 8, y * 8))
				else:
					good = False
		if not good:
			tile_img[-1].paste(Image.new('RGB', (0x20, 0x20), (0xb0, 0, 0)), (0x21 * charset_num, 0))
	all_tiles_img.paste(tile_img[-1], (offset, tile_num * 0x21))
	all_tiles_draw.text((2, tile_num * 0x21 + 0x8), '%02x' % tile_num)
all_tiles_img.save('/tmp/mogtiles.png')
# }}}

# Finally, output everything to image files and screen.
for w, im in enumerate(worldmap):
	im.save('/tmp/mog-world-%02d.png' % w)
	#print('\nRooms in world %d' % w)
	#print('\n'.join([' '.join(y) for y in textmap[w]]))
