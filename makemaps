#!/usr/bin/python3
# vim: set fileencoding=utf-8 :

# Imports {{{
import sys
import struct
import numpy
from PIL import Image
from PIL import ImageDraw
import read_patterns
import read_sprites
# }}}

# Palette {{{
palette = ((0, 0, 0,
		0, 0, 0,
		62, 184, 73,
		116, 208, 125,
		89, 85, 224,
		128, 118, 241,
		185, 94, 81,
		101, 219, 239,
		219, 101, 89,
		255, 137, 125,
		204, 195, 94,
		222, 208, 135,
		58, 162, 65,
		183, 102, 181,
		204, 204, 204,
		255, 255, 255,
	))
# }}}

def get_room_charset(room): # {{{
	'Every room has a charset (16 options). This function reads the charset id for a given room.'
	d = data[0x140d7 + (room + 1) // 2]
	if (room + 1) & 1:
		return d & 0xf
	else:
		return d >> 4
# }}}

# Prepare global data. {{{
data = open('MazeOfGalious.rom', 'rb').read()
# Get pointers for data to each world. First world is the castle.
world = struct.unpack('<' + 'H' * 11, data[0xeac0:0xead6])
# Convert pointers in CPU view to pointers in flat ROM image.
world = [x - 0x6000 + 0xe000 for x in world]
# Compute number of rooms from address of next room. This does not work for the last world, so hardcode that value.
rooms = [(world[x + 1] - world[x]) // 40 for x in range(len(world) - 1)] + [6]
# Read charset ids for all castle rooms.
charset_id = [get_room_charset(i) for i in range(rooms[0])]
# Rooms are built from tiles of 4x4 characters. There are a total of 0xac tiles defined.
tiles = numpy.array([[[data[0xe000 + t * 0x10 + y * 4 + x] for x in range(4)] for y in range(4)] for t in range(0xac)], dtype = numpy.uint8)
# }}}

# Enemy names taken from openmsx mog overlay.
enemy_names = (None, "Gorilla", "Twinkle", "HorBlob", "Gate", "Fire Snake", "06", "Ring Worm",
		"08", "09", "Knight", "Water Strider", "Sparky", "Fish", "Bat", "Pacman",
		"Insect", "Hedgehog", "Rockman", "Cloud Demon", "Mudman", "Ill", "Bird Dragon", "Egg Bird",
		"Worm", "Butterfly", "Snake's Fire", "Fireball", "1C", "1D", "1E", "Goblin",
		"Shadow Blob", "Crawler", "Pea Shooter", "Trapwall", "Swine", "Bones", "Living Helmet", "Owl",
		"Ectoplasm", "Drifting Cloud", "Poltergeist", "Wizard", "Shoe 1", "Frost Demon", "Bamboo Shoot", "Frog Plant",
		"Seahorse Demon", "Gas", "Armor>", "Armor's Dart", "Bally", "35", "DingDong", "Great Butterfly",
		"VerBlob", "39", "Moai>", "Moai Head Projectile", "Trickster Ghost", "Star", "Flocking Bird", "3F",
		"Cyclop's Ghost", "41", "Maner", "Gero", "44", "45", "46", "47",
		"48", "Huge Bat", "4A", "4B", "Fuzzball", "4D", "Fairy Dust", "4F",
		"<Moai", "<Armor", "Middle Bat", "Mini Bat", "Bone", "Small Bone", "Small Fireball", "57",
		"Crab's Breath", "Seed", "5A", "5B", "Spiral Ball ", "5D", "5E", "5F",
		"Maner's Arm", "61", "Gero's Tongue", "63", "Shoe 2", "Breath", "66", "Protectors",
		"68", "Thunder Cloud", "6A", "6B", "6C", "6D", "6E", "6F",
		"70", "71", "72", "73", "74", "75", "76", "77",
		"78", "79", "7A", "7B", "7C", "7D", "7E", "7F")

# Find sprite codes that are loaded for a room. Can be used to check that sprite patterns are available and to map sprite names to their enemy codes.
room_sprites = []
for w, num_rooms in enumerate(rooms):
	room_sprites.append([None])
	ptr = 0x17737 + 2 * (w + 1)
	ptr = struct.unpack('<H', data[ptr:ptr + 2])[0] - 0x8000 + 0x16000
	# ptr is now pointing at a list of enemy codes that are loaded for this room.
	room = 0
	for room in range(num_rooms):
		room_sprites[-1].append([])
		while data[ptr] != 0:
			room_sprites[-1][-1].append(data[ptr])
			ptr += 1
		ptr += 1

def makeimage(world_num, room_num, roomdata, charset_id, item, shrine, worlddoor, enemies, boulders, ladder): # {{{
	'Convert data into image'
	im = Image.new('RGB', (32 * 8, 20 * 8))
	for y in range(20):
		for x in range(32):
			c = read_patterns.get_char(read_patterns.sets[charset_id], roomdata[y, x])
			if roomdata[y, x] != 0x6c: # Hide walk-through walls.
				if c is not None:
					im.paste(read_patterns.get_char(read_patterns.sets[charset_id], roomdata[y, x]), (8 * x, 8 * y))
			else:
				im.paste(read_patterns.get_char(read_patterns.sets[charset_id], roomdata[y, x]), (8 * x, 8 * y), Image.new('L', (8, 8), 128))
	imt = ImageDraw.Draw(im)
	# Draw boulders first, so that what's behind can be shown on top.
	if boulders is not None:
		for x, y in boulders:
			im.paste(read_patterns.boulder_img, (x, y, x + 16, y + 16))
	if item is not None:
		item_item, item_x, item_y = item
		itemimg = read_patterns.items[item_item]
		if boulders is not None and (item_x, item_y) in boulders:
			t = Image.eval(itemimg.convert('L'), lambda p: 128 if p == 0 else 255)
			im.paste(itemimg, (item_x, item_y, item_x + itemimg.size[0], item_y + itemimg.size[1]), t)
		else:
			im.paste(itemimg, (item_x, item_y, item_x + itemimg.size[0], item_y + itemimg.size[1]))
	if shrine is not None:
		shrine_id, shrine_x, shrine_y = shrine
		if boulders is not None and (shrine_x, shrine_y) in boulders:
			t = Image.eval(read_patterns.shrine_img.convert('L'), lambda p: 128 if p == 0 else 255)
			im.paste(read_patterns.shrine_img, (shrine_x, shrine_y, shrine_x + 16, shrine_y + 16), t)
		else:
			im.paste(read_patterns.shrine_img, (shrine_x, shrine_y, shrine_x + 16, shrine_y + 16))
		imt.text((shrine_x + 5, shrine_y + 5), '%x' % shrine_id, fill = (0, 0, 255))
	if worlddoor is not None:
		num, x, y = worlddoor
		im.paste(read_patterns.worlddoor_img, (x, y, x + 32, y + 24))
		imt.text((x + 13, y + 13), '%x' % num, fill = (255, 255, 255))
	unused_enemies = set(room_sprites[world_num][room_num + 1])
	if ladder is not None:
		x, y, h = ladder
		limg = read_patterns.composite([0], [[0x9a, 0x9b]])
		t = Image.new('L', limg.size, 128)
		for i in range(h):
			print('l at %x %x' % (x, y + i))
			im.paste(limg, (x, (y + i * 8) - 0x20), t)
	if enemies is not None:
		for e in enemies:
			fixes = {0x64: 0x2c, 0x69: 0x06}
			code = fixes.get(e[0], e[0])
			num = enemies[e]
			pos = e[1], e[2] - 32
			boss_map = {0x3a: 0x00, 0x50: 0x02, 0x32: 0x04, 0x51: 0x05, 0x5c: None, 0x04: None} # Moais and armors, and baby in boulder
			if code in boss_map:
				block = boss_map[code]
				if block is None:
					if code == 4:
						# Hanging snake ("Gate"). Draw as image.
						target = read_patterns.composite([4], [[0xb5], [0x99]])
					else:
						# Baby option. Show baby in boulder.
						baby = read_sprites.bosses[0x17]
						boulder = read_sprites.bosses[0x39]
						target = baby.copy()
						target.paste(boulder, (0, 0), Image.new('L', boulder.size, 128))
				else:
					target = read_sprites.bosses[block]
				im.paste(target, pos)
			else:
				if code not in room_sprites[world_num][room_num + 1]:
					print('warning: wrong sprite in room %d %02x? %02x(%s) not in %s' % (world_num, room_num + 1, code, enemy_names[code], ','.join('%02x(%s)' % (x, enemy_names[x]) for x in room_sprites[world_num][room_num + 1])))
				elif code in unused_enemies:
					unused_enemies.remove(code)
				if code == 0x31 and not (pos[1] & 8):
					# Gas at odd row show use different sprite.
					sprite = read_sprites.sprite_imgs[code][7]
				else:
					sprite = read_sprites.sprites[code]
				im.paste(sprite, pos, sprite)
				#imt.text(pos, enemy_names[code], fill = (255, 255, 255))
			if num > 1:
				imt.text((pos[0], pos[1] + 12), 'x%d' % num, fill = (255, 255, 255))
	# TODO: show unused enemies on screen as well.
	## Show bit-pattern of character code on top line.
	#for y in range(20):
	#	for x in range(32):
	#		for bit in range(8):
	#			im.putpixel((x * 8 + bit, y * 8), 15 if (roomdata[y, x] >> (7 - bit)) & 1 else 1)
	return im
# }}}

# Make images of all rooms. {{{
out = []
for idx, w in enumerate(world):
	# Get a list of all items.
	items = {}	# key is room, value is id, x, y
	itemworldaddr = 0xb6fc + 2 * (idx + 1) - 0xa000 + 9 * 0x2000
	itemptr = struct.unpack('<H', data[itemworldaddr:itemworldaddr + 2])[0] - 0xa000 + 9 * 0x2000
	shrines = {}
	worlddoor = {}
	enemies = {}
	boulders = {}
	ladders = {}
	if idx == 0:
		# Find shrines
		target = 0x5dda
		while data[target] != 0:
			room, shrine_id, shrine_y, shrine_x = data[target:target + 4]
			# Room-1, because this data starts counting at 1. y-32, because the coordinate includes the screen header.
			shrines[room - 1] = [shrine_id, shrine_x, shrine_y - 32]
			target += 4
		# Find worlddoors
		for num, target in enumerate(range(0x9990, 0x9999)):
			room = data[target - 0x8000 + 2 * 0x2000]
			addr = 0x9997 + (num + 1) * 2 - 0x8000 + 2 * 0x2000
			y, x = data[addr:addr + 2]
			#print('door %x %x %x %x' % (num + 1, room, x, y))
			worlddoor[room - 1] = (num + 1, x, y - 32)
		# Find boulders
		target = 0xb8a2 - 0xa000 + 9 * 0x2000
		room = 0
		while room < rooms[idx]:
			if data[target] == 0:
				target += 1
				room += 1
				continue
			if room not in boulders:
				boulders[room] = []
			x = (data[target] << 3) & 0xf8
			y = ((data[target] & 0xe0) | 8) - 32
			boulders[room].append((x, y))
			target += 1
	# Find ladders
	for i in range(0xd):
		addr = 0x126eb + i * 2
		ldata = 0x12700 + (i + 1) * 5
		lw, lr = data[addr:addr + 2]
		if lw != idx + 1:
			continue
		y, x, h, _, _ = data[ldata:ldata + 5]
		ladders[lr - 1] = [x, y, h]
	print(ladders)
	# Find enemies
	target = 0xb5cb + (idx + 1) * 2 - 0xa000 + 6 * 0x2000
	e = struct.unpack('<H', data[target:target + 2])[0] - 0xa000 + 6 * 0x2000
	room = 0
	while room < rooms[idx]:
		if data[e] == 0:
			room += 1
			e += 1
			continue
		if room not in enemies:
			enemies[room] = {}
		etype = data[e] & 0x7f
		ey = data[e + 1] & 0xf8
		ex = ((data[e + 1] << 5) | ((data[e] & 0x80) >> 3)) & 0xf0
		record = (etype, ex, ey)
		if record not in enemies[room]:
			enemies[room][record] = 0
		enemies[room][record] += 1
		#print('enemy %s at %02x %02x in room %02x world %d' % (enemy_names[etype], ex, ey, room + 1, idx))
		e += 2
	while data[itemptr] != 0:
		# Data is: room(8-bit) x4,x3,item(6-bit) y7,y6,y5,y4,y3,x7,x6,x5
		room, xitem, yx = data[itemptr:itemptr + 3]
		item = xitem & 0x3f
		y = yx & 0xf8
		x = ((yx & 0x7) << 5) | ((xitem & 0xc0) >> 3)
		# Weapons are half height.
		if item < 7:
			y += 8
		items[room - 1] = (item, x, y - 32)
		#print('item found @%x: world %x room %x item %x x %x y %x' % (itemptr, idx, room, item, x, y))
		itemptr += 3
	# Create all rooms in a world.
	fullmap = numpy.zeros((rooms[idx], 20, 32), dtype = numpy.uint8)
	# Read tiles in a room (8x5, so 40 bytes total).
	roomdata = numpy.array([[x for x in data[w + 40 * room:w + 40 * (room + 1)]] for room in range(rooms[idx])], dtype = numpy.uint8).reshape((rooms[idx], 5, 8))
	# Unpack characters from tiles.
	for y in range(5):
		for x in range(8):
			fullmap[:, y * 4:(y + 1) * 4, x * 4:(x + 1) * 4] = [tiles[roomdata[r, y, x]] for r in range(rooms[idx])]
	# Convert character map to image.
	worldmap = []
	for r in range(rooms[idx]):
		it = items.get(r)
		sh = shrines.get(r)
		wd = worlddoor.get(r)
		e = enemies.get(r)
		b = boulders.get(r)
		l = ladders.get(r)
		#print('world %d room %x' % (idx, r))
		worldmap.append(makeimage(idx, r, fullmap[r], charset_id[r] if idx == 0 else 7, it, sh, wd, e, b, l))
	out.append(worldmap)
# }}}

# Link stuff together. {{{
worldmap = []
textmap = []
invalid = Image.new('P', (256, 160), 13)
# Prepare data structure for storing all room exits.
exits = [numpy.zeros((4, rooms[w]), dtype = numpy.uint8) for w in range(11)]
# Compute bounding box.
l = [[0, 0] for w in range(11)]
h = [[0, 0] for w in range(11)]
for w in range(11):
	waddr = 0x129f1 + 2 * w
	# Convert from CPU view to flat ROM address.
	a = struct.unpack('<H', data[waddr:waddr + 2])[0] - 0xa000 + 0x12000
	# Read all exits.
	for r in range(rooms[w]):
		raddr = a + 4 * (r + 1)
		exits[w][:, r] = struct.unpack('<BBBB', data[raddr:raddr + 4])
	# check if values are sane.
	for r in range(rooms[w]):
		for e in range(4):
			target = exits[w][e, r]
			# rooms[w] + 1 is meeting a god; 0xff - w is world exit
			if target == 0xff or target == 0xff - w or target == rooms[w] + 1:
				#print 'world %d, found room %x' % (w, target)
				continue
			if not 0 < target <= rooms[w]:
				print('invalid exit %d=%x for room %x world %d' % (e, target, r, w))
				continue
			# World 4, room 4 has an upper exit to itself; ignore it.
			if (r + 1, w + 1, e) != (4, 4, 0) and exits[w][e ^ 1, target - 1] != r + 1:
				print("exit %d=%x for room %x world %d doesn't return (%x)" % (e, exits[w][e, r], r + 1, w + 1, exits[w][e ^ 1, exits[w][e, r] - 1]))
				continue
			#print 'exit %d room %x world %d is %x; exit %d room %x world %d is %x' % (e, r, w, target, e ^ 1, target, w, exits[w][e ^ 1, target - 1])
	# compute screen positions. Do a flood fill and compute bounding boxes along the way.
	screenpos = {1: numpy.array((0, 0))}
	queue = [list(screenpos.keys())[0]]
	done = set()
	todo = set(range(1, rooms[w] + 1))
	delta = numpy.array(((0, -1), (0, 1), (-1, 0), (1, 0)))
	if w == 0:
		# Screen 94 is not linked, but belongs at (1,-1). Link it there.
		screenpos[94] = numpy.array((1, -1))
		todo.remove(94)
		done.add(94)
		h[w][0] = 1
		l[w][1] = -1
	elif w == 10:
		# Screen 6 is not linked, but belongs at (5,0). Link it there.
		screenpos[6] = numpy.array((5, 0))
		todo.remove(6)
		done.add(6)
		h[w][0] = 5
	while queue != []:
		current = queue.pop(0)
		todo.remove(current)
		for e in range(4):
			target = exits[w][e, current - 1]
			if target == 0xff:
				continue
			# World 4, room 4 has an upper exit to itself; ignore it.
			if w == 3 and current == 4 and e == 0:
				assert current == target
				continue
			if target in screenpos:
				if not all(screenpos[target] == screenpos[current] + delta[e]):
					print('screen %d exists in different position (%s != %s)' % (target, str(screenpos[target]), str(screenpos[current] + delta[e])))
				continue
			# Add screen in any case.
			x, y = screenpos[current] + delta[e]
			double = [s for s in screenpos if screenpos[s][0] == x and screenpos[s][1] == y]
			if double != []:
				print('two screens in one position: %x %x' % (double[0], target))
			screenpos[target] = x, y
			# Update bounding box.
			if x < l[w][0]:
				l[w][0] = x
			if x > h[w][0]:
				h[w][0] = x
			if y < l[w][1]:
				l[w][1] = y
			if y > h[w][1]:
				h[w][1] = y
			# Only add real screens to queue.
			if 0 < target <= rooms[w]:
				queue.append(target)
		done.add(current)
	#print('done: %d/%d, todo: %s, w,h=%d,%d' % (len(done), rooms[w], str(todo), h[w][0] - l[w][0], h[w][1] - l[w][1]))
#print '\n'.join(['world %d; address: %05x rooms: %d' % (n, x, rooms[n]) for n, x in enumerate(world)])

	# Create the world image.
	size = h[w][0] - l[w][0] + 1, h[w][1] - l[w][1] + 1
	textmap.append([['  ' for x in range(size[0])] for y in range(size[1])])
	worldmap.append(Image.new('RGB', (size[0] * 257 - 1, size[1] * 161 - 1), (0, 0, 0)))
	worldmapt = ImageDraw.Draw(worldmap[w])
	for sp in screenpos:
		tx = screenpos[sp][0] - l[w][0]
		ty = screenpos[sp][1] - l[w][1]
		# Add 1 pixel to separate screens in the image.
		x = tx * 257
		y = ty * 161
		if 0 < sp <= rooms[w]: 
			debug_charset = False	# w == 0	# Use this to debug charsets castle.
			worldmap[w].paste(out[w][sp - 1], (x, y, x + 256, y + 160))
			textmap[w][ty][tx] = '%02x' % sp
			worldmapt.rectangle((x, y, x + 15 + (15 if debug_charset else 0), y + 10), fill = (0, 0, 0))
			if debug_charset:
				worldmapt.text((x + 2, y), "%02x/%x" % (sp, charset_id[sp - 1]), fill = (255, 255, 255))
			else:
				worldmapt.text((x + 2, y), "%02x" % sp, fill = (255, 255, 255))
		else:
			worldmap[w].paste(invalid, (x, y, x + 256, y + 160))
			textmap[w][ty][tx] = '++'
# }}}

# Finally, output everything to image files and screen.
for w, im in enumerate(worldmap):
	im.save('/tmp/mog-world-%02d.png' % w)
	print('\nRooms in world %d' % w)
	print('\n'.join([' '.join(y) for y in textmap[w]]))
